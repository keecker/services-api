package com.keecker.services.interfaces.projection

import android.os.Parcel
import android.os.Parcelable
/**
 * Aggregates information about the projector:
 *  - settings
 *  - position
 *  - power
 *
 * @param orientation Angle between the projected image bottom and the horizon. Between 0 and 78 degrees.
 * @param focus Focus knob position between 0 and 100.
 * @param autoFocus Automatically set the focus based on wall distance. Overrides [focus].
 * @param autoKeystone Automatically set the keystone based on [orientation]
 * @param disabled No longer used.
 * @param powerOn Tells if the projector is powered.
 * @param ledOn Tells if the LEDs are on.
 * @param keystone Shapes the image. Between -40 and 40 degrees.
 * @param zoom Projected image zoom. Between 0 and 100.
 * @param brightness Projected image brightness between 0 and 100.
 * @param contrast Projected image contrast between 0 and 100.
 * @param displayMode [DisplayMode]
 * @param displayPosition [DisplayPosition]
 * @param aspectRatio [AspectRatio]
 */
data class ProjectorState(
        val orientation: Int? = null,
        val focus: Int? = null,
        val autoFocus: Boolean? = null,
        val autoKeystone: Boolean? = null,
        @Deprecated("No longer used")
        val disabled: Boolean? = null,
        val powerOn: Boolean? = null,
        val ledOn: Boolean? = null,
        val keystone: Int? = null,
        val zoom: Int? = null,
        val brightness: Int? = null,
        val contrast: Int? = null,
        val displayMode: DisplayMode? = null,
        val displayPosition: DisplayPosition? = null,
        val aspectRatio: AspectRatio? = null
) : Parcelable {

    /*
     * TODO(cyril) Provide a way to set the focus value in meters
     * TODO(cyril) Remap to -50 50
     */

    /**
     * [Parcelable] boilerplate.
     */
    companion object CREATOR : Parcelable.Creator<ProjectorState> {

        /**
         * [Parcelable] boilerplate.
         */
        override fun createFromParcel(parcel: Parcel): ProjectorState {
            return ProjectorState(
            readIntegerOrNull(parcel),
            readIntegerOrNull(parcel),
            readBooleanOrNull(parcel),
            readBooleanOrNull(parcel),
            readBooleanOrNull(parcel),
            readBooleanOrNull(parcel),
            readBooleanOrNull(parcel),
            readIntegerOrNull(parcel),
            readIntegerOrNull(parcel),
            readIntegerOrNull(parcel),
            readIntegerOrNull(parcel),
            readParcelableOrNull<DisplayMode>(parcel, DisplayMode::class.java.classLoader) as DisplayMode?,
            readParcelableOrNull<DisplayPosition>(parcel, DisplayPosition::class.java.classLoader) as DisplayPosition?,
            readParcelableOrNull<AspectRatio>(parcel, AspectRatio::class.java.classLoader) as AspectRatio?)

        }

        /**
         * [Parcelable] boilerplate.
         */
        override fun newArray(size: Int): Array<ProjectorState?> {
            return arrayOfNulls(size)
        }

        // This parcelable used to be generated by paperparcel.
        // Those function were written to ditch the dependency
        // while keeping the same parceled data.
        // Consider moving them elsewhere if needed.

        private fun writeIntegerOrNull(i: Int?, out: Parcel) {
            if (i != null) {
                out.writeInt(1)
                out.writeInt(i)
            } else {
                out.writeInt(0)
            }
        }

        private fun writeBooleanOrNull(b: Boolean?, out: Parcel) {
            if (b != null) {
                out.writeInt(1)
                out.writeInt(if (b) 1 else 0)
            } else {
                out.writeInt(0)
            }
        }

        private fun writeParcelableOrNull(p: Parcelable?, out: Parcel, flags: Int) {
            if (p != null) {
                out.writeInt(1)
                out.writeParcelable(p, flags)
            } else {
                out.writeInt(0)
            }
        }

        private fun readIntegerOrNull(parcel: Parcel): Int? {
            return if (parcel.readInt() == 1) {
                parcel.readInt()
            } else {
                null
            }
        }

        private fun readBooleanOrNull(parcel: Parcel): Boolean? {
            return if (parcel.readInt() == 1) {
                parcel.readInt() == 1
            } else {
                null
            }
        }

        private fun <T : Parcelable> readParcelableOrNull(parcel: Parcel, loader: ClassLoader): T? {
            return if (parcel.readInt() == 1) {
                parcel.readParcelable(loader)
            } else {
                null
            }
        }

        /**
         * Default settings, mainly used for unit tests.
         */
        @JvmStatic
        val defaultState = ProjectorState(
            orientation = 10,
            focus = 50,
            autoFocus = false,
            autoKeystone = false,
            disabled = false,
            powerOn = true,
            ledOn = true,
            keystone = 0,
            zoom = 50,
            brightness = 50,
            contrast = 50,
            displayMode = DisplayMode.USER,
            displayPosition = DisplayPosition.FRONT_TABLE,
            aspectRatio = AspectRatio.R16_9)
    }

    /**
     * [Parcelable] boilerplate.
     */
    override fun describeContents() = 0

    /**
     * [Parcelable] boilerplate.
     */
    override fun writeToParcel(dest: Parcel, flags: Int) {
        writeIntegerOrNull(orientation, dest)
        writeIntegerOrNull(focus, dest)
        writeBooleanOrNull(autoFocus, dest)
        writeBooleanOrNull(autoKeystone, dest)
        writeBooleanOrNull(disabled, dest)
        writeBooleanOrNull(powerOn, dest)
        writeBooleanOrNull(ledOn, dest)
        writeIntegerOrNull(keystone, dest)
        writeIntegerOrNull(zoom, dest)
        writeIntegerOrNull(brightness, dest)
        writeIntegerOrNull(contrast, dest)
        writeParcelableOrNull(displayMode, dest, flags)
        writeParcelableOrNull(displayPosition, dest, flags)
        writeParcelableOrNull(aspectRatio, dest, flags)
    }

    fun withOrientation(value: Int): ProjectorState {
        return copy(orientation = value)
    }

    fun withFocus(value: Int): ProjectorState {
        return copy(focus = value)
    }

    fun withKeystone(value: Int): ProjectorState {
        return copy(keystone = value)
    }
}
